// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: feeds_queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createNewFavoriteOnPost = `-- name: CreateNewFavoriteOnPost :one
INSERT INTO favorite_posts (
    post_id, 
    feed_id, 
    user_id
    )
VALUES ($1, $2, $3)
RETURNING id, created_at
`

type CreateNewFavoriteOnPostParams struct {
	PostID int64
	FeedID int64
	UserID int64
}

type CreateNewFavoriteOnPostRow struct {
	ID        int64
	CreatedAt time.Time
}

func (q *Queries) CreateNewFavoriteOnPost(ctx context.Context, arg CreateNewFavoriteOnPostParams) (CreateNewFavoriteOnPostRow, error) {
	row := q.db.QueryRowContext(ctx, createNewFavoriteOnPost, arg.PostID, arg.FeedID, arg.UserID)
	var i CreateNewFavoriteOnPostRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createNewFeed = `-- name: CreateNewFeed :one
INSERT INTO feeds (
    user_id,
    name, 
    url, 
    img_url,
    feed_type, 
    feed_category, 
    feed_description,
    is_hidden
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, created_at, updated_at, version, approval_status
`

type CreateNewFeedParams struct {
	UserID          int64
	Name            string
	Url             string
	ImgUrl          sql.NullString
	FeedType        FeedType
	FeedCategory    string
	FeedDescription sql.NullString
	IsHidden        bool
}

type CreateNewFeedRow struct {
	ID             int64
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Version        int32
	ApprovalStatus FeedApprovalStatus
}

func (q *Queries) CreateNewFeed(ctx context.Context, arg CreateNewFeedParams) (CreateNewFeedRow, error) {
	row := q.db.QueryRowContext(ctx, createNewFeed,
		arg.UserID,
		arg.Name,
		arg.Url,
		arg.ImgUrl,
		arg.FeedType,
		arg.FeedCategory,
		arg.FeedDescription,
		arg.IsHidden,
	)
	var i CreateNewFeedRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.ApprovalStatus,
	)
	return i, err
}

const createRssFeedPost = `-- name: CreateRssFeedPost :one
INSERT INTO rssfeed_posts (
    channeltitle, 
    channelurl,
    channeldescription,
    channellanguage,
    itemtitle,
    itemdescription,
    itempublished_at, 
    itemcontent,
    itemurl, 
    img_url, 
    feed_id
)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9, $10, $11)
RETURNING id, created_at, updated_at
`

type CreateRssFeedPostParams struct {
	Channeltitle       string
	Channelurl         sql.NullString
	Channeldescription sql.NullString
	Channellanguage    sql.NullString
	Itemtitle          string
	Itemdescription    sql.NullString
	ItempublishedAt    time.Time
	Itemcontent        sql.NullString
	Itemurl            string
	ImgUrl             string
	FeedID             int64
}

type CreateRssFeedPostRow struct {
	ID        int64
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateRssFeedPost(ctx context.Context, arg CreateRssFeedPostParams) (CreateRssFeedPostRow, error) {
	row := q.db.QueryRowContext(ctx, createRssFeedPost,
		arg.Channeltitle,
		arg.Channelurl,
		arg.Channeldescription,
		arg.Channellanguage,
		arg.Itemtitle,
		arg.Itemdescription,
		arg.ItempublishedAt,
		arg.Itemcontent,
		arg.Itemurl,
		arg.ImgUrl,
		arg.FeedID,
	)
	var i CreateRssFeedPostRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const deleteFavoriteOnPost = `-- name: DeleteFavoriteOnPost :one
DELETE FROM favorite_posts
WHERE post_id = $1 AND user_id = $2
RETURNING id
`

type DeleteFavoriteOnPostParams struct {
	PostID int64
	UserID int64
}

func (q *Queries) DeleteFavoriteOnPost(ctx context.Context, arg DeleteFavoriteOnPostParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteFavoriteOnPost, arg.PostID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteFeedByID = `-- name: DeleteFeedByID :one
DELETE FROM feeds
WHERE id = $1 AND user_id = $2
RETURNING id
`

type DeleteFeedByIDParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteFeedByID(ctx context.Context, arg DeleteFeedByIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteFeedByID, arg.ID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAllFeeds = `-- name: GetAllFeeds :many
SELECT count(*) OVER() AS total_count, 
    id, 
    user_id,
    name, 
    url, 
    img_url,
    feed_type,
    feed_category,
    feed_description,
    is_hidden,
    approval_status,
    version,
    created_at, 
    updated_at 
FROM feeds
WHERE ($1 = '' OR to_tsvector('simple', name) @@ plainto_tsquery('simple', $1))
AND feed_type = $2 OR $2 = ''
AND is_hidden = FALSE
AND approval_status='approved'
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetAllFeedsParams struct {
	Column1  interface{}
	FeedType FeedType
	Limit    int32
	Offset   int32
}

type GetAllFeedsRow struct {
	TotalCount      int64
	ID              int64
	UserID          int64
	Name            string
	Url             string
	ImgUrl          sql.NullString
	FeedType        FeedType
	FeedCategory    string
	FeedDescription sql.NullString
	IsHidden        bool
	ApprovalStatus  FeedApprovalStatus
	Version         int32
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) GetAllFeeds(ctx context.Context, arg GetAllFeedsParams) ([]GetAllFeedsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllFeeds,
		arg.Column1,
		arg.FeedType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFeedsRow
	for rows.Next() {
		var i GetAllFeedsRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Url,
			&i.ImgUrl,
			&i.FeedType,
			&i.FeedCategory,
			&i.FeedDescription,
			&i.IsHidden,
			&i.ApprovalStatus,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRSSPostWithFavoriteTag = `-- name: GetAllRSSPostWithFavoriteTag :many
SELECT 
    COUNT(*) OVER() AS total_count,
    p.id,
    p.created_at,
    p.updated_at,
    p.channeltitle,
    p.channelurl,
    p.channeldescription,
    p.channellanguage,
    p.itemtitle,
    p.itemdescription,
    p.itemcontent,
    p.itempublished_at,
    p.itemurl,
    p.img_url,
    p.feed_id,
    CASE WHEN fp.post_id IS NOT NULL THEN true ELSE false END AS is_favorite  -- Check if the post is favorited
FROM 
    rssfeed_posts p
LEFT JOIN 
    favorite_posts fp ON p.id = fp.post_id AND fp.user_id = $1  -- Check if the post is in the favorites table for the user
WHERE 
    ($2 = '' OR to_tsvector('simple', p.itemtitle) @@ plainto_tsquery('simple', $2))  -- Full-text search for item title
    AND ($3 = 0 OR p.feed_id = $3)  -- Filter by feed_id if provided, return all posts if feed_id is NULL
ORDER BY 
    p.created_at DESC
LIMIT $4 OFFSET $5
`

type GetAllRSSPostWithFavoriteTagParams struct {
	UserID  int64
	Column2 interface{}
	Column3 interface{}
	Limit   int32
	Offset  int32
}

type GetAllRSSPostWithFavoriteTagRow struct {
	TotalCount         int64
	ID                 int64
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Channeltitle       string
	Channelurl         sql.NullString
	Channeldescription sql.NullString
	Channellanguage    sql.NullString
	Itemtitle          string
	Itemdescription    sql.NullString
	Itemcontent        sql.NullString
	ItempublishedAt    time.Time
	Itemurl            string
	ImgUrl             string
	FeedID             int64
	IsFavorite         bool
}

func (q *Queries) GetAllRSSPostWithFavoriteTag(ctx context.Context, arg GetAllRSSPostWithFavoriteTagParams) ([]GetAllRSSPostWithFavoriteTagRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllRSSPostWithFavoriteTag,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRSSPostWithFavoriteTagRow
	for rows.Next() {
		var i GetAllRSSPostWithFavoriteTagRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Channeltitle,
			&i.Channelurl,
			&i.Channeldescription,
			&i.Channellanguage,
			&i.Itemtitle,
			&i.Itemdescription,
			&i.Itemcontent,
			&i.ItempublishedAt,
			&i.Itemurl,
			&i.ImgUrl,
			&i.FeedID,
			&i.IsFavorite,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedByID = `-- name: GetFeedByID :one
SELECT
    id,
    user_id,
    name,
    url,
    img_url,
    feed_type,
    feed_category,
    feed_description,
    is_hidden,
    approval_status,
    version,
    created_at,
    updated_at
FROM feeds
WHERE id = $1
`

type GetFeedByIDRow struct {
	ID              int64
	UserID          int64
	Name            string
	Url             string
	ImgUrl          sql.NullString
	FeedType        FeedType
	FeedCategory    string
	FeedDescription sql.NullString
	IsHidden        bool
	ApprovalStatus  FeedApprovalStatus
	Version         int32
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) GetFeedByID(ctx context.Context, id int64) (GetFeedByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getFeedByID, id)
	var i GetFeedByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Url,
		&i.ImgUrl,
		&i.FeedType,
		&i.FeedCategory,
		&i.FeedDescription,
		&i.IsHidden,
		&i.ApprovalStatus,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextFeedsToFetch = `-- name: GetNextFeedsToFetch :many
SELECT
    id,
    user_id,
    name,
    url,
    img_url,
    feed_type,
    feed_category,
    feed_description,
    is_hidden,
    approval_status,
    version,
    created_at,
    updated_at
FROM feeds
WHERE approval_status = 'approved'
ORDER BY last_fetched_at ASC NULLS FIRST
LIMIT $1
`

type GetNextFeedsToFetchRow struct {
	ID              int64
	UserID          int64
	Name            string
	Url             string
	ImgUrl          sql.NullString
	FeedType        FeedType
	FeedCategory    string
	FeedDescription sql.NullString
	IsHidden        bool
	ApprovalStatus  FeedApprovalStatus
	Version         int32
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) GetNextFeedsToFetch(ctx context.Context, limit int32) ([]GetNextFeedsToFetchRow, error) {
	rows, err := q.db.QueryContext(ctx, getNextFeedsToFetch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNextFeedsToFetchRow
	for rows.Next() {
		var i GetNextFeedsToFetchRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Url,
			&i.ImgUrl,
			&i.FeedType,
			&i.FeedCategory,
			&i.FeedDescription,
			&i.IsHidden,
			&i.ApprovalStatus,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRssFeedPostByID = `-- name: GetRssFeedPostByID :one
SELECT
    id,
    channeltitle,
    channelurl,
    channeldescription,
    channellanguage,
    itemtitle,
    itemdescription,
    itempublished_at,
    itemcontent,
    itemurl,
    img_url,
    feed_id,
    created_at,
    updated_at
FROM rssfeed_posts
WHERE id = $1
`

type GetRssFeedPostByIDRow struct {
	ID                 int64
	Channeltitle       string
	Channelurl         sql.NullString
	Channeldescription sql.NullString
	Channellanguage    sql.NullString
	Itemtitle          string
	Itemdescription    sql.NullString
	ItempublishedAt    time.Time
	Itemcontent        sql.NullString
	Itemurl            string
	ImgUrl             string
	FeedID             int64
	CreatedAt          time.Time
	UpdatedAt          time.Time
}

func (q *Queries) GetRssFeedPostByID(ctx context.Context, id int64) (GetRssFeedPostByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getRssFeedPostByID, id)
	var i GetRssFeedPostByIDRow
	err := row.Scan(
		&i.ID,
		&i.Channeltitle,
		&i.Channelurl,
		&i.Channeldescription,
		&i.Channellanguage,
		&i.Itemtitle,
		&i.Itemdescription,
		&i.ItempublishedAt,
		&i.Itemcontent,
		&i.Itemurl,
		&i.ImgUrl,
		&i.FeedID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markFeedAsFetched = `-- name: MarkFeedAsFetched :one
UPDATE feeds
SET last_fetched_at = NOW()
WHERE id = $1
RETURNING id, user_id, name, url, img_url, feed_type, feed_category, feed_description, is_hidden, approval_status, version, created_at, updated_at, last_fetched_at
`

func (q *Queries) MarkFeedAsFetched(ctx context.Context, id int64) (Feed, error) {
	row := q.db.QueryRowContext(ctx, markFeedAsFetched, id)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Url,
		&i.ImgUrl,
		&i.FeedType,
		&i.FeedCategory,
		&i.FeedDescription,
		&i.IsHidden,
		&i.ApprovalStatus,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastFetchedAt,
	)
	return i, err
}

const updateFeed = `-- name: UpdateFeed :one
UPDATE feeds
SET
    name = $2,
    url = $3,
    img_url = $4,
    feed_type = $5,
    feed_category = $6,
    feed_description = $7,
    is_hidden = $8,
    approval_status = $9,
    version = version + 1
WHERE id = $1 AND user_id = $10 AND version = $11
RETURNING updated_at, version
`

type UpdateFeedParams struct {
	ID              int64
	Name            string
	Url             string
	ImgUrl          sql.NullString
	FeedType        FeedType
	FeedCategory    string
	FeedDescription sql.NullString
	IsHidden        bool
	ApprovalStatus  FeedApprovalStatus
	UserID          int64
	Version         int32
}

type UpdateFeedRow struct {
	UpdatedAt time.Time
	Version   int32
}

func (q *Queries) UpdateFeed(ctx context.Context, arg UpdateFeedParams) (UpdateFeedRow, error) {
	row := q.db.QueryRowContext(ctx, updateFeed,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.ImgUrl,
		arg.FeedType,
		arg.FeedCategory,
		arg.FeedDescription,
		arg.IsHidden,
		arg.ApprovalStatus,
		arg.UserID,
		arg.Version,
	)
	var i UpdateFeedRow
	err := row.Scan(&i.UpdatedAt, &i.Version)
	return i, err
}

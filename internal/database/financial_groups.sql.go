// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: financial_groups.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkIfGroupMembersAreMaxedOut = `-- name: CheckIfGroupMembersAreMaxedOut :one
SELECT COUNT(*) AS member_count, g.max_member_count
FROM group_memberships gm
JOIN groups g ON g.id = gm.group_id
WHERE gm.group_id = $1
GROUP BY g.max_member_count
`

type CheckIfGroupMembersAreMaxedOutRow struct {
	MemberCount    int64
	MaxMemberCount sql.NullInt32
}

func (q *Queries) CheckIfGroupMembersAreMaxedOut(ctx context.Context, groupID sql.NullInt64) (CheckIfGroupMembersAreMaxedOutRow, error) {
	row := q.db.QueryRowContext(ctx, checkIfGroupMembersAreMaxedOut, groupID)
	var i CheckIfGroupMembersAreMaxedOutRow
	err := row.Scan(&i.MemberCount, &i.MaxMemberCount)
	return i, err
}

const createNewGroupInvitation = `-- name: CreateNewGroupInvitation :one
INSERT INTO group_invitations (
    group_id, inviter_user_id, invitee_user_email, status) 
VALUES ($1, $2, $3, $4)
RETURNING id, status, sent_at, expiration_date
`

type CreateNewGroupInvitationParams struct {
	GroupID          sql.NullInt64
	InviterUserID    sql.NullInt64
	InviteeUserEmail string
	Status           InvitationStatusType
}

type CreateNewGroupInvitationRow struct {
	ID             int64
	Status         InvitationStatusType
	SentAt         sql.NullTime
	ExpirationDate time.Time
}

func (q *Queries) CreateNewGroupInvitation(ctx context.Context, arg CreateNewGroupInvitationParams) (CreateNewGroupInvitationRow, error) {
	row := q.db.QueryRowContext(ctx, createNewGroupInvitation,
		arg.GroupID,
		arg.InviterUserID,
		arg.InviteeUserEmail,
		arg.Status,
	)
	var i CreateNewGroupInvitationRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.SentAt,
		&i.ExpirationDate,
	)
	return i, err
}

const createNewUserGroup = `-- name: CreateNewUserGroup :one
INSERT INTO groups (
    creator_user_id, group_image_url, name, is_private, max_member_count, description
) VALUES 
($1, $2, $3, $4, $5, $6)
RETURNING id, creator_user_id, activity_count, last_activity_at, created_at, updated_at, version
`

type CreateNewUserGroupParams struct {
	CreatorUserID  sql.NullInt64
	GroupImageUrl  string
	Name           string
	IsPrivate      sql.NullBool
	MaxMemberCount sql.NullInt32
	Description    sql.NullString
}

type CreateNewUserGroupRow struct {
	ID             int64
	CreatorUserID  sql.NullInt64
	ActivityCount  sql.NullInt32
	LastActivityAt sql.NullTime
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	Version        sql.NullInt32
}

func (q *Queries) CreateNewUserGroup(ctx context.Context, arg CreateNewUserGroupParams) (CreateNewUserGroupRow, error) {
	row := q.db.QueryRowContext(ctx, createNewUserGroup,
		arg.CreatorUserID,
		arg.GroupImageUrl,
		arg.Name,
		arg.IsPrivate,
		arg.MaxMemberCount,
		arg.Description,
	)
	var i CreateNewUserGroupRow
	err := row.Scan(
		&i.ID,
		&i.CreatorUserID,
		&i.ActivityCount,
		&i.LastActivityAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const getGroupById = `-- name: GetGroupById :one
SELECT
    id,
    creator_user_id,
    group_image_url,
    name,
    is_private,
    max_member_count,
    description,
    activity_count,
    last_activity_at,
    created_at,
    updated_at,
    version
FROM groups
WHERE id = $1
`

func (q *Queries) GetGroupById(ctx context.Context, id int64) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupById, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.CreatorUserID,
		&i.GroupImageUrl,
		&i.Name,
		&i.IsPrivate,
		&i.MaxMemberCount,
		&i.Description,
		&i.ActivityCount,
		&i.LastActivityAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const getGroupInvitationById = `-- name: GetGroupInvitationById :one
SELECT
    id,
    group_id,
    inviter_user_id,
    invitee_user_email,
    status,
    sent_at,
    responded_at,
    expiration_date
FROM group_invitations 
WHERE invitee_user_email = $1            -- This checks if the invitee matches the user we are checking for.
  AND group_id = $2                   -- This checks if the invitation is for the specific group.
  AND status = 'pending'              -- This ensures that the invitation is still pending.
  AND expiration_date > NOW()
`

type GetGroupInvitationByIdParams struct {
	InviteeUserEmail string
	GroupID          sql.NullInt64
}

func (q *Queries) GetGroupInvitationById(ctx context.Context, arg GetGroupInvitationByIdParams) (GroupInvitation, error) {
	row := q.db.QueryRowContext(ctx, getGroupInvitationById, arg.InviteeUserEmail, arg.GroupID)
	var i GroupInvitation
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.InviterUserID,
		&i.InviteeUserEmail,
		&i.Status,
		&i.SentAt,
		&i.RespondedAt,
		&i.ExpirationDate,
	)
	return i, err
}

const updateExpiredGroupInvitations = `-- name: UpdateExpiredGroupInvitations :exec
UPDATE group_invitations
SET status = 'expired'
WHERE status = 'pending' AND expiration_date < NOW()
`

func (q *Queries) UpdateExpiredGroupInvitations(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, updateExpiredGroupInvitations)
	return err
}

const updateGroupInvitationStatus = `-- name: UpdateGroupInvitationStatus :one


UPDATE group_invitations
SET status = $1, responded_at = NOW()
WHERE id = $2
RETURNING responded_at
`

type UpdateGroupInvitationStatusParams struct {
	Status InvitationStatusType
	ID     int64
}

// This ensures the invitation hasn't expired.
func (q *Queries) UpdateGroupInvitationStatus(ctx context.Context, arg UpdateGroupInvitationStatusParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, updateGroupInvitationStatus, arg.Status, arg.ID)
	var responded_at sql.NullTime
	err := row.Scan(&responded_at)
	return responded_at, err
}

const updateUserGroup = `-- name: UpdateUserGroup :one
UPDATE groups SET
    group_image_url = $1,
    name = $2,
    is_private = $3,
    max_member_count = $4,
    description = $5,
    activity_count = $6,
    last_activity_at = $7,
    updated_at = NOW(),
    version = version + 1
WHERE
    id = $8 AND version = $9 AND creator_user_id = $10
RETURNING updated_at
`

type UpdateUserGroupParams struct {
	GroupImageUrl  string
	Name           string
	IsPrivate      sql.NullBool
	MaxMemberCount sql.NullInt32
	Description    sql.NullString
	ActivityCount  sql.NullInt32
	LastActivityAt sql.NullTime
	ID             int64
	Version        sql.NullInt32
	CreatorUserID  sql.NullInt64
}

func (q *Queries) UpdateUserGroup(ctx context.Context, arg UpdateUserGroupParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, updateUserGroup,
		arg.GroupImageUrl,
		arg.Name,
		arg.IsPrivate,
		arg.MaxMemberCount,
		arg.Description,
		arg.ActivityCount,
		arg.LastActivityAt,
		arg.ID,
		arg.Version,
		arg.CreatorUserID,
	)
	var updated_at sql.NullTime
	err := row.Scan(&updated_at)
	return updated_at, err
}

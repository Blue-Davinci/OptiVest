// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: financial_manager_queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createNewBudget = `-- name: CreateNewBudget :one
INSERT INTO budgets (
    user_id, 
    name, 
    is_Strict, 
    category, 
    total_amount, 
    currency_code, 
    conversion_rate, 
    description 
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at
`

type CreateNewBudgetParams struct {
	UserID         int64
	Name           string
	IsStrict       bool
	Category       string
	TotalAmount    string
	CurrencyCode   string
	ConversionRate string
	Description    sql.NullString
}

type CreateNewBudgetRow struct {
	ID        int64
	CreatedAt time.Time
	UpdatedAt time.Time
}

//-----------------------------------------------------------------------------------------------------
//----------------------- Budgets
//-----------------------------------------------------------------------------------------------------
func (q *Queries) CreateNewBudget(ctx context.Context, arg CreateNewBudgetParams) (CreateNewBudgetRow, error) {
	row := q.db.QueryRowContext(ctx, createNewBudget,
		arg.UserID,
		arg.Name,
		arg.IsStrict,
		arg.Category,
		arg.TotalAmount,
		arg.CurrencyCode,
		arg.ConversionRate,
		arg.Description,
	)
	var i CreateNewBudgetRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createNewGoal = `-- name: CreateNewGoal :one
INSERT INTO goals (
    user_id, 
    budget_id, 
    name, 
    current_amount, 
    target_amount, 
    monthly_contribution, 
    start_date, 
    end_date, 
    status
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, created_at, updated_at
`

type CreateNewGoalParams struct {
	UserID              int64
	BudgetID            sql.NullInt64
	Name                string
	CurrentAmount       sql.NullString
	TargetAmount        string
	MonthlyContribution string
	StartDate           time.Time
	EndDate             time.Time
	Status              GoalStatus
}

type CreateNewGoalRow struct {
	ID        int64
	CreatedAt time.Time
	UpdatedAt time.Time
}

//-----------------------------------------------------------------------------------------------------
//----------------------- Goals
//-----------------------------------------------------------------------------------------------------
func (q *Queries) CreateNewGoal(ctx context.Context, arg CreateNewGoalParams) (CreateNewGoalRow, error) {
	row := q.db.QueryRowContext(ctx, createNewGoal,
		arg.UserID,
		arg.BudgetID,
		arg.Name,
		arg.CurrentAmount,
		arg.TargetAmount,
		arg.MonthlyContribution,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
	)
	var i CreateNewGoalRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const deleteBudgetById = `-- name: DeleteBudgetById :one
DELETE FROM budgets
WHERE id = $1 AND user_id = $2
RETURNING id
`

type DeleteBudgetByIdParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteBudgetById(ctx context.Context, arg DeleteBudgetByIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteBudgetById, arg.ID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAllGoalsByBudgetID = `-- name: GetAllGoalsByBudgetID :many
SELECT count(*) OVER(),
    g.id AS goal_id,
    g.user_id AS user_id,
    g.budget_id AS budget_id,
    g.name AS goal_name,
    g.current_amount AS current_amount,
    g.target_amount AS goal_target_amount,
    g.monthly_contribution AS monthly_amount,
    g.start_date AS start_date,
    g.end_date AS end_date,
    g.status AS goal_status,
    b.total_amount - COALESCE(SUM(g.monthly_contribution) OVER (), 0) AS total_surplus
FROM 
    goals g
JOIN 
    budgets b ON g.budget_id = b.id
WHERE 
    b.id = $1 and b.user_id = $2
GROUP BY 
    g.id, g.name, g.target_amount, g.monthly_contribution, b.total_amount
LIMIT $3 OFFSET $4
`

type GetAllGoalsByBudgetIDParams struct {
	ID     int64
	UserID int64
	Limit  int32
	Offset int32
}

type GetAllGoalsByBudgetIDRow struct {
	Count            int64
	GoalID           int64
	UserID           int64
	BudgetID         sql.NullInt64
	GoalName         string
	CurrentAmount    sql.NullString
	GoalTargetAmount string
	MonthlyAmount    string
	StartDate        time.Time
	EndDate          time.Time
	GoalStatus       GoalStatus
	TotalSurplus     int32
}

func (q *Queries) GetAllGoalsByBudgetID(ctx context.Context, arg GetAllGoalsByBudgetIDParams) ([]GetAllGoalsByBudgetIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllGoalsByBudgetID,
		arg.ID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGoalsByBudgetIDRow
	for rows.Next() {
		var i GetAllGoalsByBudgetIDRow
		if err := rows.Scan(
			&i.Count,
			&i.GoalID,
			&i.UserID,
			&i.BudgetID,
			&i.GoalName,
			&i.CurrentAmount,
			&i.GoalTargetAmount,
			&i.MonthlyAmount,
			&i.StartDate,
			&i.EndDate,
			&i.GoalStatus,
			&i.TotalSurplus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetByID = `-- name: GetBudgetByID :one
SELECT 
    id, 
    user_id, 
    name,
    is_strict, 
    category, 
    total_amount, 
    currency_code, 
    conversion_rate,
    description, 
    created_at, 
    updated_at
FROM budgets
WHERE id = $1
`

func (q *Queries) GetBudgetByID(ctx context.Context, id int64) (Budget, error) {
	row := q.db.QueryRowContext(ctx, getBudgetByID, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.IsStrict,
		&i.Category,
		&i.TotalAmount,
		&i.CurrencyCode,
		&i.ConversionRate,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBudgetsForUser = `-- name: GetBudgetsForUser :many
SELECT count(*) OVER(),
    id, 
    user_id, 
    name,
    is_strict, 
    category, 
    total_amount, 
    currency_code, 
    conversion_rate,
    description, 
    created_at, 
    updated_at
FROM budgets
WHERE user_id = $1
AND ($2 = '' OR to_tsvector('simple', name) @@ plainto_tsquery('simple', $2))
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetBudgetsForUserParams struct {
	UserID  int64
	Column2 interface{}
	Limit   int32
	Offset  int32
}

type GetBudgetsForUserRow struct {
	Count          int64
	ID             int64
	UserID         int64
	Name           string
	IsStrict       bool
	Category       string
	TotalAmount    string
	CurrencyCode   string
	ConversionRate string
	Description    sql.NullString
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) GetBudgetsForUser(ctx context.Context, arg GetBudgetsForUserParams) ([]GetBudgetsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getBudgetsForUser,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBudgetsForUserRow
	for rows.Next() {
		var i GetBudgetsForUserRow
		if err := rows.Scan(
			&i.Count,
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.IsStrict,
			&i.Category,
			&i.TotalAmount,
			&i.CurrencyCode,
			&i.ConversionRate,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBudgetById = `-- name: UpdateBudgetById :one
UPDATE budgets
SET 
    name = $2,
    is_strict = $3,
    category = $4,
    total_amount = $5,
    currency_code = $6,
    conversion_rate = $7,
    description = $8
WHERE id = $1 and user_id = $9
RETURNING updated_at
`

type UpdateBudgetByIdParams struct {
	ID             int64
	Name           string
	IsStrict       bool
	Category       string
	TotalAmount    string
	CurrencyCode   string
	ConversionRate string
	Description    sql.NullString
	UserID         int64
}

func (q *Queries) UpdateBudgetById(ctx context.Context, arg UpdateBudgetByIdParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, updateBudgetById,
		arg.ID,
		arg.Name,
		arg.IsStrict,
		arg.Category,
		arg.TotalAmount,
		arg.CurrencyCode,
		arg.ConversionRate,
		arg.Description,
		arg.UserID,
	)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}
